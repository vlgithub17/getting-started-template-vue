import { DatabaseResponse, Connection, ProgressCallback, GetRecordQuery, FetchOptions, RecordData, Condition, UserAttributes, UserProfile, Newsletters, Form, PostRecordConfig, PublicUser } from '../Types';
import { extractFormData, fromBase62, generateRandom, toBase62, MD5 } from '../utils/utils';
export default class Skapi {
    private __version;
    service: string;
    owner: string;
    session: Record<string, any> | null;
    connection: Connection | null;
    private host;
    private hostDomain;
    private target_cdn;
    private __disabledAccount;
    private __cached_requests;
    private __startKeyHistory;
    private __request_signup_confirmation;
    private __private_access_key;
    private __class_properties_has_been_cached;
    private __user;
    get user(): UserProfile | null;
    set user(value: UserProfile | null);
    admin_endpoint: Promise<Record<string, any>>;
    record_endpoint: Promise<Record<string, any>>;
    validate: {
        userId(val: string): boolean;
        url(val: string | string[]): boolean;
        phoneNumber(val: string): boolean;
        birthdate(val: string): boolean;
        email(val: string): boolean;
    };
    util: {
        MD5: typeof MD5;
        generateRandom: typeof generateRandom;
        toBase62: typeof toBase62;
        fromBase62: typeof fromBase62;
        extractFormData: typeof extractFormData;
        request: (url: string, data?: Form<any>, options?: {
            fetchOptions?: FetchOptions;
            auth?: boolean;
            method?: string;
            bypassAwaitConnection?: boolean;
            responseType?: 'json' | 'blob' | 'text' | 'arrayBuffer' | 'formData' | 'document';
            contentType?: string;
        }) => Promise<any>;
    };
    private __connection;
    private __authConnection;
    private __socket;
    private __socket_room;
    private __network_logs;
    constructor(service: string, owner: string, options?: {
        autoLogin: boolean;
    }, __etc?: any);
    updateConnection(): Promise<Connection>;
    private registerTicket;
    private unregisterTicket;
    version(): string;
    connectRealtime(cb: (rt: {
        type: 'message' | 'error' | 'success' | 'close' | 'notice' | 'private';
        message: any;
        sender?: string;
        sender_cid?: string;
    }) => Promise<WebSocket>): Promise<WebSocket>;
    jwtLogin(params: {
        idToken: string;
        keyUrl: string;
        clientId: string;
        provider: string;
        nonce?: string;
    }): Promise<UserProfile>;
    clientSecretRequest(params: {
        url: string;
        clientSecretName: string;
        method: 'GET' | 'POST' | 'DELETE' | 'PUT';
        headers?: {
            [key: string]: string;
        };
        data?: {
            [key: string]: any;
        };
        params?: {
            [key: string]: string;
        };
    }): Promise<any>;
    consumeTicket(params: {
        ticket_id: string;
    } & {
        [key: string]: any;
    }): Promise<any>;
    getConsumedTickets(params: {
        ticket_id?: string;
    }, fetchOptions: FetchOptions): Promise<DatabaseResponse<any[]>>;
    getTickets(params: {
        ticket_id?: string;
    }, fetchOptions: FetchOptions): Promise<DatabaseResponse<any[]>>;
    closeRealtime(): Promise<void>;
    getRealtimeUsers(params: {
        group: string;
        user_id?: string;
    }, fetchOptions?: FetchOptions): Promise<DatabaseResponse<{
        user_id: string;
        connection_id: string;
    }[]>>;
    sendInquiry(data: Form<{
        name: string;
        email: string;
        subject: string;
        message: string;
    }>): Promise<"SUCCESS: Inquiry has been sent.">;
    getRealtimeGroups(params?: {
        searchFor: 'group' | 'number_of_users';
        value: string | number;
        condition?: '>' | '>=' | '=' | '<' | '<=' | '!=' | 'gt' | 'gte' | 'eq' | 'lt' | 'lte' | 'ne';
        range?: string | number;
    } | null, fetchOptions?: FetchOptions): Promise<DatabaseResponse<{
        group: string;
        number_of_users: number;
    }>>;
    postRealtime(message: any, recipient: string): Promise<{
        type: 'success';
        message: 'Message sent.';
    }>;
    joinRealtime(params: {
        group: string | null;
    }): Promise<{
        type: 'success';
        message: string;
    }>;
    getConnection(): Promise<Connection>;
    getProfile(options?: {
        refreshToken: boolean;
    }): Promise<UserProfile | null>;
    getFile(url: string, config?: {
        dataType?: 'base64' | 'download' | 'endpoint' | 'blob' | 'text';
        expires?: number;
        progress?: ProgressCallback;
    }): Promise<Blob | string | void>;
    secureRequest<Params = {
        url: string;
        data?: any;
        sync?: boolean;
    }, Response = {
        response: any;
        statusCode: number;
        url: string;
    }>(params: Params | Params[]): Promise<Response | Response[]>;
    getFormResponse(): Promise<any>;
    getRecords(query: GetRecordQuery, fetchOptions?: FetchOptions): Promise<DatabaseResponse<RecordData>>;
    getTables(query: {
        table: string;
        condition?: Condition;
    }, fetchOptions?: FetchOptions): Promise<DatabaseResponse<{
        number_of_records: number;
        table: string;
        size: number;
    }>>;
    getIndexes(query: {
        table: string;
        index?: string;
        order?: {
            by: 'average_number' | 'total_number' | 'number_count' | 'average_bool' | 'total_bool' | 'bool_count' | 'string_count' | 'index_name';
            value?: number | boolean | string;
            condition?: Condition;
        };
    }, fetchOptions?: FetchOptions): Promise<DatabaseResponse<{
        table: string;
        index: string;
        number_of_records: number;
        string_count?: number;
        number_count?: number;
        boolean_count?: number;
        total_number?: number;
        total_bool?: number;
        average_number?: number;
        average_bool?: number;
    }>>;
    getTags(query: {
        table: string;
        tag?: string;
        condition?: Condition;
    }, fetchOptions?: FetchOptions): Promise<DatabaseResponse<{
        table: string;
        tag: string;
        number_of_records: string;
    }>>;
    deleteRecords(params: {
        record_id?: string | string[];
        table?: {
            name: string;
            access_group?: number | 'private' | 'public' | 'authorized';
            subscription: boolean;
        };
    }): Promise<string>;
    resendSignupConfirmation(redirect: string): Promise<'SUCCESS: Signup confirmation E-Mail has been sent.'>;
    recoverAccount(redirect?: boolean | string): Promise<"SUCCESS: Recovery e-mail has been sent.">;
    getUsers(params?: {
        searchFor: 'user_id' | 'email' | 'phone_number' | 'locale' | 'name' | 'address' | 'gender' | 'birthdate' | 'subscribers' | 'timestamp';
        value: string | number | boolean;
        condition?: '>' | '>=' | '=' | '<' | '<=' | '!=' | 'gt' | 'gte' | 'eq' | 'lt' | 'lte' | 'ne';
        range?: string | number | boolean;
    }, fetchOptions?: FetchOptions): Promise<DatabaseResponse<PublicUser>>;
    disableAccount(): Promise<'SUCCESS: account has been disabled.'>;
    lastVerifiedEmail(params?: {
        revert: boolean;
    }): Promise<string | UserProfile>;
    unsubscribeNewsletter(params: {
        group: number | 'public' | 'authorized' | null;
    }): Promise<string>;
    getNewsletters(params?: {
        searchFor: 'message_id' | 'timestamp' | 'read' | 'complaint' | 'subject';
        value: string | number;
        range: string | number;
        condition?: '>' | '>=' | '=' | '<' | '<=' | 'gt' | 'gte' | 'eq' | 'lt' | 'lte';
        group: 'public' | 'authorized' | number;
    }, fetchOptions?: FetchOptions): Promise<DatabaseResponse<Newsletters>>;
    getNewsletterSubscription(params: {
        group?: number | 'public' | 'authorized';
    }): Promise<{
        active: boolean;
        timestamp: number;
        group: number;
        subscribed_email: string;
    }[]>;
    requestUsernameChange(params: {
        redirect?: string;
        username: string;
    }): Promise<'SUCCESS: confirmation e-mail has been sent.'>;
    grantPrivateRecordAccess(params: {
        record_id: string;
        user_id: string | string[];
    }): Promise<string>;
    removePrivateRecordAccess(params: {
        record_id: string;
        user_id: string | string[];
    }): Promise<string>;
    listPrivateRecordAccess(params: {
        record_id: string;
        user_id: string | string[];
    }): Promise<DatabaseResponse<{
        record_id: string;
        user_id: string;
    }>>;
    requestPrivateRecordAccessKey(record_id: string): Promise<string>;
    deleteFiles(params: {
        endpoints: string | string[];
    }): Promise<RecordData[]>;
    uploadFiles(fileList: FormData | HTMLFormElement | SubmitEvent, params: {
        record_id: string;
        progress?: ProgressCallback;
    }): Promise<{
        completed: File[];
        failed: File[];
        bin_endpoints: string[];
    }>;
    mock(data: Form<any | {
        raise: 'ERR_INVALID_REQUEST' | 'ERR_INVALID_PARAMETER' | 'SOMETHING_WENT_WRONG' | 'ERR_EXISTS' | 'ERR_NOT_EXISTS';
    }>, options?: {
        auth?: boolean;
        method?: string;
        bypassAwaitConnection?: boolean;
        responseType?: 'blob' | 'json' | 'text' | 'arrayBuffer' | 'formData' | 'document';
        contentType?: string;
        progress?: ProgressCallback;
    }): Promise<{
        mockResponse: Record<string, any>;
    }>;
    login(form: Form<{
        username?: string;
        email: string;
        password: string;
    }>): Promise<UserProfile>;
    logout(): Promise<'SUCCESS: The user has been logged out.'>;
    signup(form: Form<UserAttributes & {
        email: String;
        password: String;
        username?: string;
    }>, option?: {
        signup_confirmation?: boolean | string;
        email_subscription?: boolean;
        login?: boolean;
    } & {
        progress?: ProgressCallback;
    }): Promise<UserProfile | "SUCCESS: The account has been created. User's signup confirmation is required." | 'SUCCESS: The account has been created.'>;
    resetPassword(form: Form<{
        email: string;
        code: string | number;
        new_password: string;
    }>): Promise<"SUCCESS: New password has been set.">;
    verifyEmail(form?: Form<{
        code: string;
    }>): Promise<string>;
    verifyPhoneNumber(form?: Form<{
        code: string;
    }>): Promise<string>;
    forgotPassword(form: Form<{
        email: string;
    }>): Promise<"SUCCESS: Verification code has been sent.">;
    changePassword(params: {
        new_password: string;
        current_password: string;
    }): Promise<'SUCCESS: Password has been changed.'>;
    updateProfile(form: Form<UserAttributes>): Promise<UserProfile>;
    postRecord(form: Form<Record<string, any>> | null | undefined, config: PostRecordConfig & {
        progress?: ProgressCallback;
    }): Promise<RecordData>;
    getSubscriptions(params: {
        subscriber?: string;
        subscription?: string;
        blocked?: boolean;
    }, fetchOptions?: FetchOptions): Promise<DatabaseResponse<{
        subscriber: string;
        subscription: string;
        group: number;
        timestamp: number;
        blocked: boolean;
    }>>;
    subscribe(params: {
        user_id: string;
    }): Promise<'SUCCESS: the user has subscribed.'>;
    unsubscribe(params: {
        user_id: string;
    }): Promise<'SUCCESS: the user has unsubscribed.'>;
    blockSubscriber(params: {
        user_id: string;
    }): Promise<'SUCCESS: blocked user id "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".'>;
    unblockSubscriber(params: {
        user_id: string;
    }): Promise<'SUCCESS: unblocked user id "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".'>;
    subscribeNewsletter(params: Form<{
        email?: string;
        group: number | 'public' | 'authorized';
        redirect?: string;
    }>): Promise<string>;
}
