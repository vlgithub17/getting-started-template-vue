import SkapiError from '../main/error';
import validator from './validator';
import { MD5, generateRandom, extractFormData } from './utils';
async function getEndpoint(dest, auth) {
    const endpoints = await Promise.all([
        this.admin_endpoint,
        this.record_endpoint
    ]);
    const admin = endpoints[0];
    const record = endpoints[1];
    let params = dest.split('?');
    let query = params.length > 1 ? '?' + params[1] : '';
    dest = params[0];
    switch (dest) {
        case 'get-newsletters':
        case 'get-public-newsletters':
        case 'get-users':
        case 'post-userdata':
        case 'remove-account':
        case 'post-secure':
        case 'subscribe-newsletter':
        case 'subscribe-public-newsletter':
        case 'admin-signup':
        case 'confirm-signup':
        case 'recover-account':
        case 'mock':
        case 'service':
        case 'grant-access':
        case 'last-verified-email':
        case 'ticket':
        case 'register-ticket':
        case 'get-newsletter-subscription':
        case 'request-username-change':
        case 'jwt-login':
        case 'client-secret-request':
        case 'signupkey':
        case 'send-inquiry':
        case 'client-secret-request-public':
            return (auth ? admin.admin_private : admin.admin_public) + dest + query;
        case 'post-record':
        case 'get-records':
        case 'subscription':
        case 'get-subscription':
        case 'del-records':
        case 'get-table':
        case 'get-tag':
        case 'get-index':
        case 'get-signed-url':
        case 'grant-private-access':
        case 'request-private-access-key':
        case 'get-ws-group':
        case 'del-files':
            return (auth ? record.record_private : record.record_public) + dest + query;
        default:
            return validator.Url(dest);
    }
}
const __pendingRequest = {};
export async function request(url, data = null, options, _etc) {
    if (this.__network_logs) {
        console.log(JSON.parse(JSON.stringify({ url, data, options })));
    }
    options = options || {};
    let { auth = false, method = 'post', bypassAwaitConnection = false, } = options;
    method = method.toUpperCase();
    let __connection = null;
    let service = this.service;
    let owner = this.owner;
    let token = null;
    let endpoint = await getEndpoint.bind(this)(url, !!auth);
    if (!bypassAwaitConnection) {
        __connection = await this.__connection;
        if (!__connection) {
            throw new SkapiError('Invalid connection. The service could have been disabled, or has a restricted CORS.', { code: 'INVALID_REQUEST' });
        }
    }
    if (auth) {
        if (this.session) {
            let currTime = Date.now() / 1000;
            if (this.session.idToken.payload.exp < currTime) {
                try {
                    await this.authentication().getSession({ refreshToken: true });
                }
                catch (err) {
                    this.logout();
                    throw new SkapiError('User login is required.', { code: 'INVALID_REQUEST' });
                }
            }
            token = this.session?.idToken?.jwtToken;
        }
        else {
            this.logout();
            throw new SkapiError('User login is required.', { code: 'INVALID_REQUEST' });
        }
    }
    let fetchOptions = {};
    let { fetchMore = false, progress } = options?.fetchOptions || {};
    if (options?.fetchOptions && Object.keys(options.fetchOptions).length) {
        for (let k of ['limit', 'startKey', 'ascending']) {
            if (options.fetchOptions.hasOwnProperty(k)) {
                fetchOptions[k] = options.fetchOptions[k];
            }
        }
        fetchOptions = validator.Params(fetchOptions, {
            limit: v => {
                if (typeof v !== 'number') {
                    throw new SkapiError('Fetch limit should be a number.', { code: 'INVALID_REQUEST' });
                }
                if (v > 1000) {
                    throw new SkapiError('Fetch limit should be below 1000.', { code: 'INVALID_REQUEST' });
                }
                return v;
            },
            startKey: v => v,
            ascending: 'boolean'
        });
    }
    let required = _etc?.ignoreService ? {} : { service, owner };
    Object.assign(required, fetchOptions);
    data = extractFormData(data).data;
    if (!data) {
        data = required;
    }
    else if (data && typeof data === 'object') {
        data = Object.assign(required, data);
    }
    let hashedParams = (() => {
        if (data && typeof data === 'object' && Object.keys(data).length && !(data instanceof FormData)) {
            function sortObject(obj) {
                if (typeof obj === 'object' && obj !== null) {
                    return Object.keys(obj)
                        .sort()
                        .reduce((res, key) => {
                        if (typeof obj[key] === 'object' && obj[key] !== null) {
                            res[key] = sortObject(obj[key]);
                        }
                        else {
                            res[key] = obj[key];
                        }
                        return res;
                    }, {});
                }
                return obj;
            }
            ;
            return MD5.hash(url + '/' + JSON.stringify(sortObject(data)));
        }
        return MD5.hash(url + '/' + this.service);
    })();
    let requestKey = load_startKey_keys.bind(this)({
        params: data,
        url,
        fetchMore,
        hashedParams
    });
    if (!requestKey || requestKey && typeof requestKey === 'object') {
        return requestKey;
    }
    if (typeof requestKey === 'string' && __pendingRequest[requestKey] instanceof Promise) {
        return __pendingRequest[requestKey];
    }
    let headers = {
        'Accept': '*/*',
        "Content-Type": options.hasOwnProperty('contentType') ? options.contentType === null ? 'application/x-www-form-urlencoded' : options.contentType : 'application/json'
    };
    if (token) {
        headers.Authorization = token;
    }
    let opt = { headers };
    if (options?.responseType) {
        opt.responseType = options.responseType;
    }
    if (method === 'GET') {
        if (data) {
            let query = [];
            if (data instanceof FormData) {
                for (let [name, value] of data.entries()) {
                    if (typeof value === 'string') {
                        value = encodeURIComponent(value);
                        query.push(`&${name}=${value}`);
                    }
                }
            }
            else {
                query = Object.keys(data)
                    .map(k => {
                    let value = data[k];
                    if (typeof value !== 'string') {
                        value = JSON.stringify(value);
                    }
                    return encodeURIComponent(k) + '=' + encodeURIComponent(value);
                });
            }
            if (query.length) {
                if (endpoint.substring(endpoint.length - 1) !== '?') {
                    endpoint = endpoint + '?';
                }
                endpoint += query.join('&');
            }
        }
        opt.body = null;
    }
    else {
        opt.body = data ? JSON.stringify(data) : null;
    }
    opt.method = method;
    __pendingRequest[requestKey] = _fetch.bind(this)(endpoint, opt, progress);
    try {
        return update_startKey_keys.bind(this)({
            hashedParam: requestKey,
            url,
            fetched: await __pendingRequest[requestKey]
        });
    }
    finally {
        if (requestKey && __pendingRequest.hasOwnProperty(requestKey)) {
            delete __pendingRequest[requestKey];
        }
    }
}
function load_startKey_keys(option) {
    let { params = {}, url, fetchMore = false, hashedParams } = option || {};
    if (params.startKey) {
        if (!(typeof params.startKey === 'object' && Object.keys(params.startKey).length) &&
            params.startKey !== 'start' && params.startKey !== 'end') {
            throw new SkapiError(`"${params.startKey}" is invalid startKey key.`, { code: 'INVALID_PARAMETER' });
        }
        if (params.startKey === 'start') {
            fetchMore = false;
            delete params.startKey;
        }
    }
    if (!fetchMore && this.__startKeyHistory?.[url]?.[hashedParams]) {
        if (this.__cached_requests?.[url]?.[hashedParams]) {
            delete this.__cached_requests[url][hashedParams];
        }
        if (Array.isArray(this.__startKeyHistory[url][hashedParams]) && this.__startKeyHistory[url][hashedParams].length) {
            for (let p of this.__startKeyHistory[url][hashedParams]) {
                let hashedParams_cached = hashedParams + MD5.hash(p);
                if (this.__cached_requests?.[url] && this.__cached_requests?.[url]?.[hashedParams_cached]) {
                    delete this.__cached_requests[url][hashedParams_cached];
                }
            }
        }
        delete this.__startKeyHistory[url][hashedParams];
        return hashedParams;
    }
    if (!Array.isArray(this.__startKeyHistory?.[url]?.[hashedParams])) {
        return hashedParams;
    }
    let list_of_startKeys = this.__startKeyHistory[url][hashedParams];
    let last_startKey_key = list_of_startKeys[list_of_startKeys.length - 1];
    let cache_hashedParams = hashedParams;
    if (last_startKey_key) {
        if (last_startKey_key === 'end') {
            return {
                list: [],
                startKey: 'end',
                endOfList: true,
                startKeyHistory: list_of_startKeys
            };
        }
        else {
            cache_hashedParams += MD5.hash(last_startKey_key);
            params.startKey = JSON.parse(last_startKey_key);
        }
    }
    if (this.__cached_requests?.[url]?.[cache_hashedParams]) {
        return this.__cached_requests[url][cache_hashedParams];
    }
    return hashedParams;
}
function _fetch(url, opt, progress) {
    return new Promise((res, rej) => {
        let xhr = new XMLHttpRequest();
        xhr.open(opt.method || 'GET', url);
        for (var k in opt.headers || {}) {
            xhr.setRequestHeader(k, opt.headers[k]);
        }
        if (opt.responseType) {
            xhr.responseType = opt.responseType;
        }
        xhr.onload = () => {
            if (xhr.status < 400) {
                if (opt.responseType == 'json' || opt.responseType == 'blob') {
                    res(xhr.response);
                }
                else {
                    let result = xhr.responseText;
                    try {
                        result = JSON.parse(result);
                    }
                    catch (err) { }
                    res(result);
                }
            }
            else if (xhr.status === 429) {
                let retryAfter = xhr.getResponseHeader('Retry-After');
                if (retryAfter) {
                    setTimeout(() => {
                        _fetch(url, opt, progress).then(res, rej);
                    }, parseInt(retryAfter) * 1000);
                }
                else {
                    rej('Too many requests');
                }
            }
            else {
                let status = xhr.status;
                let errCode = [
                    'INVALID_CORS',
                    'INVALID_REQUEST',
                    'SERVICE_DISABLED',
                    'INVALID_PARAMETER',
                    'ERROR',
                    'EXISTS',
                    'NOT_EXISTS'
                ];
                let result = xhr.responseText;
                try {
                    result = JSON.parse(result);
                }
                catch (err) { }
                if (typeof result === 'string') {
                    let errMsg = xhr.response.split(':');
                    let code = errMsg.splice(0, 1)[0].trim();
                    rej(new SkapiError(errMsg.join(':').trim(), { code: (errCode.includes(code) ? code : 'ERROR') }));
                }
                else if (typeof result === 'object' && result?.message) {
                    let code = (result?.code || (status ? status.toString() : null) || 'ERROR');
                    let msg = result.message;
                    if (typeof msg === 'string') {
                        msg = msg.trim();
                    }
                    rej(new SkapiError(msg, { code: code }));
                }
                else {
                    rej(result);
                }
            }
        };
        xhr.onerror = () => rej('Network error');
        xhr.onabort = () => rej('Aborted');
        xhr.ontimeout = () => rej('Timeout');
        if (typeof progress === 'function') {
            xhr.onprogress = (p) => {
                progress({
                    status: 'download',
                    progress: p.loaded / p.total * 100,
                    loaded: p.loaded,
                    total: p.total,
                    abort: () => xhr.abort()
                });
            };
            if (xhr.upload) {
                xhr.upload.onprogress = (p) => {
                    progress({
                        status: 'upload',
                        progress: p.loaded / p.total * 100,
                        loaded: p.loaded,
                        total: p.total,
                        abort: () => xhr.abort()
                    });
                };
            }
        }
        xhr.send(opt.body);
    });
}
function update_startKey_keys(option) {
    let { hashedParam, url, fetched } = option;
    if (!fetched?.startKey) {
        return fetched;
    }
    if (!this.__startKeyHistory.hasOwnProperty(url)) {
        this.__startKeyHistory[url] = {};
    }
    if (!this.__cached_requests?.[url]) {
        this.__cached_requests[url] = {};
    }
    this.__cached_requests[url][hashedParam] = fetched;
    if (!this.__startKeyHistory[url].hasOwnProperty(hashedParam)) {
        this.__startKeyHistory[url][hashedParam] = [];
    }
    let startKey_string = fetched.startKey === 'end' ? 'end' : JSON.stringify(fetched.startKey);
    if (!this.__startKeyHistory[url][hashedParam].includes(startKey_string)) {
        this.__startKeyHistory[url][hashedParam].push(startKey_string);
    }
    return Object.assign({ startKeyHistory: this.__startKeyHistory[url][hashedParam] }, fetched);
}
export async function uploadFiles(fileList, params) {
    await this.__connection;
    let { record_id, service = this.service, progress } = params;
    if (!record_id) {
        throw new SkapiError('"record_id" is required.', { code: 'INVALID_PARAMETER' });
    }
    if (fileList instanceof SubmitEvent) {
        fileList = fileList.target;
    }
    if (fileList instanceof HTMLFormElement) {
        fileList = new FormData(fileList);
    }
    if (!(fileList instanceof FormData)) {
        throw new SkapiError('"fileList" should be a FormData or HTMLFormElement.', { code: 'INVALID_PARAMETER' });
    }
    let reserved_key = generateRandom();
    let getSignedParams = {
        reserved_key,
        service,
        request: 'post'
    };
    if (params?.record_id) {
        getSignedParams.id = params.record_id;
    }
    let xhr;
    let fetchProgress = (url, body, progressCallback) => {
        return new Promise((res, rej) => {
            xhr = new XMLHttpRequest();
            xhr.open('POST', url);
            xhr.onload = () => {
                let result = xhr.responseText;
                try {
                    result = JSON.parse(result);
                }
                catch (err) { }
                if (xhr.status >= 200 && xhr.status < 300) {
                    res(result);
                }
                else if (xhr.status === 429) {
                    let retryAfter = xhr.getResponseHeader('Retry-After');
                    if (retryAfter) {
                        setTimeout(() => {
                            fetchProgress(url, body, progressCallback).then(res, rej);
                        }, parseInt(retryAfter) * 1000);
                    }
                    else {
                        rej('Too many requests');
                    }
                }
                else {
                    rej(result);
                }
            };
            xhr.onerror = () => rej('Network error');
            xhr.onabort = () => rej('Aborted');
            xhr.ontimeout = () => rej('Timeout');
            if (xhr.upload && typeof progressCallback === 'function') {
                xhr.upload.onprogress = progressCallback;
            }
            xhr.send(body);
        });
    };
    let completed = [];
    let failed = [];
    function toBase62(num) {
        const base62Chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        if (num === 0)
            return base62Chars[0];
        let result = '';
        while (num > 0) {
            result = base62Chars[num % 62] + result;
            num = Math.floor(num / 62);
        }
        return result;
    }
    let bin_endpoints = [];
    for (let [key, f] of fileList.entries()) {
        if (!(f instanceof File)) {
            continue;
        }
        let signedParams = Object.assign({
            key: key + '/' + f.name,
            sizeKey: toBase62(f.size),
            contentType: f.type || null
        }, getSignedParams);
        let { fields = null, url, cdn } = await request.bind(this)('get-signed-url', signedParams, { auth: true });
        bin_endpoints.push(cdn);
        let form = new FormData();
        for (let name in fields) {
            form.append(name, fields[name]);
        }
        form.append('file', f);
        try {
            await fetchProgress(url, form, typeof progress === 'function' ? (p) => progress({
                status: 'upload',
                progress: p.loaded / p.total * 100,
                currentFile: f,
                completed,
                failed,
                loaded: p.loaded,
                total: p.total,
                abort: () => xhr.abort()
            }) : null);
            completed.push(f);
        }
        catch (err) {
            failed.push(f);
        }
    }
    return { completed, failed, bin_endpoints };
}
const pendPromise = {};
export function formHandler(options) {
    let { preventMultipleCalls = false } = options || {};
    return function (target, propertyKey, descriptor) {
        const fn = descriptor.value;
        descriptor.value = function (...arg) {
            let form = arg[0];
            let storeResponseKey = true;
            let formEl = null;
            let actionDestination = '';
            let fileBase64String = {};
            let refreshPage = false;
            if (form instanceof SubmitEvent) {
                form.preventDefault();
                let currentUrl = window.location.href;
                formEl = form.target;
                let href = new URL(formEl.action);
                actionDestination = href.href;
                let placeholders = actionDestination ? actionDestination.match(/(?<=\{).*?(?=\})/g) : '';
                if (placeholders) {
                    for (let p of placeholders) {
                        if (!p) {
                            continue;
                        }
                        let inputElement = formEl.querySelector(`[name="${p}"]`);
                        if (!inputElement) {
                            continue;
                        }
                        if (inputElement.type === 'file') {
                            for (let i = 0; i <= inputElement.files.length - 1; i++) {
                                if (!inputElement.files[i])
                                    continue;
                                if (!fileBase64String[p]) {
                                    fileBase64String[p] = [];
                                }
                                fileBase64String[p].push(new Promise((res, rej) => {
                                    let reader = new FileReader();
                                    reader.onload = function () {
                                        res(reader.result);
                                    };
                                    reader.readAsDataURL(inputElement.files[i]);
                                    reader.onerror = rej;
                                }));
                            }
                        }
                        else {
                            actionDestination = actionDestination.replace(`{${p}}`, inputElement.value);
                        }
                    }
                }
                if (formEl.getAttribute('action') === null) {
                    storeResponseKey = false;
                }
                else {
                    refreshPage = href.href === currentUrl;
                }
            }
            const handleResponse = async (response) => {
                if (actionDestination) {
                    for (let k in fileBase64String) {
                        if (fileBase64String[k].length) {
                            actionDestination = actionDestination.replace(`{${k}}`, (await Promise.all(fileBase64String[k])).join(','));
                        }
                    }
                }
                if (formEl) {
                    if (storeResponseKey) {
                        window.sessionStorage.setItem(`${this.service}:${MD5.hash(actionDestination)}`, JSON.stringify(response));
                        if (refreshPage) {
                            window.location.replace(actionDestination);
                        }
                        else {
                            window.location.href = actionDestination;
                        }
                    }
                }
                return response;
            };
            let response;
            let handleError = (err) => {
                if (err instanceof SkapiError) {
                    err.name = propertyKey + '()';
                }
                else {
                    err = err instanceof Error ? err : new SkapiError(err, { name: propertyKey + '()' });
                }
                throw err;
            };
            const executeMethod = async () => {
                try {
                    response = fn.bind(this)(...arg);
                    if (response instanceof Promise) {
                        let resolved = await response;
                        await handleResponse(resolved);
                        return response;
                    }
                }
                catch (err) {
                    throw handleError(err);
                }
            };
            if (preventMultipleCalls) {
                if (!pendPromise?.[propertyKey]) {
                    pendPromise[propertyKey] = executeMethod().finally(() => {
                        delete pendPromise[propertyKey];
                    });
                }
                return pendPromise[propertyKey];
            }
            return executeMethod();
        };
    };
}
export async function getFormResponse() {
    await this.__connection;
    let responseKey = `${this.service}:${MD5.hash(window.location.href.split('?')[0])}`;
    let stored = window.sessionStorage.getItem(responseKey);
    if (stored !== null) {
        try {
            stored = JSON.parse(stored);
        }
        catch (err) { }
        return stored;
    }
    return null;
}
;
//# sourceMappingURL=network.js.map