import SkapiError from '../main/error';
import validator from '../utils/validator';
import { request } from '../utils/network';
export async function clientSecretRequest(params) {
    let hasSecret = false;
    let checkClientSecretPlaceholder = (v) => {
        for (let k in v) {
            if (typeof v[k] === 'string' && v[k].includes('$CLIENT_SECRET')) {
                hasSecret = true;
                break;
            }
        }
    };
    validator.Params(params, {
        url: (v) => {
            if (!v || typeof v !== 'string') {
                throw new SkapiError('"url" should be type: <string>.', { code: 'INVALID_PARAMETER' });
            }
            validator.Url(v);
            if (v.includes('$CLIENT_SECRET')) {
                hasSecret = true;
            }
            return v;
        },
        clientSecretName: 'string',
        method: (v) => {
            if (v && typeof v !== 'string') {
                throw new SkapiError('"method" should be either "GET" or "POST" or "DELETE" or "PUT".', { code: 'INVALID_PARAMETER' });
            }
            let lo = v.toLowerCase();
            if (lo !== 'get' && lo !== 'post' && lo !== 'delete' && lo !== 'put') {
                throw new SkapiError('"method" should be either "GET" or "POST" or "DELETE" or "PUT".', { code: 'INVALID_PARAMETER' });
            }
            return lo;
        },
        headers: (v) => {
            if (v && typeof v !== 'object') {
                throw new SkapiError('"headers" should be type: <object>.', { code: 'INVALID_PARAMETER' });
            }
            checkClientSecretPlaceholder(v);
            return v;
        },
        data: (v) => {
            if (v && typeof v !== 'object') {
                throw new SkapiError('"data" should be type: <object>.', { code: 'INVALID_PARAMETER' });
            }
            checkClientSecretPlaceholder(v);
            return v;
        },
        params: (v) => {
            if (v && typeof v !== 'object') {
                throw new SkapiError('"params" should be type: <object>.', { code: 'INVALID_PARAMETER' });
            }
            checkClientSecretPlaceholder(v);
            return v;
        }
    }, ['clientSecretName', 'method', 'url']);
    if (!hasSecret) {
        throw new SkapiError(`At least one parameter value should include "$CLIENT_SECRET" in ${params.method.toLowerCase() === 'post' ? '"data"' : '"params"'} or "headers".`, { code: 'INVALID_PARAMETER' });
    }
    await this.__connection;
    let auth = !!this.__user;
    return request.bind(this)("client-secret-request" + (!auth ? '' : '-public'), params, { auth });
}
export async function sendInquiry(data) {
    await this.__connection;
    let params = {
        name: 'string',
        email: v => {
            validator.Email(v);
            return v;
        },
        subject: 'string',
        message: 'string'
    };
    data = validator.Params(data, params, [
        'name',
        'email',
        'subject',
        'message'
    ]);
    await request.bind(this)('send-inquiry', data);
    return 'SUCCESS: Inquiry has been sent.';
}
export async function secureRequest(params) {
    await this.__connection;
    let paramsStruct = {
        url: (v) => {
            return validator.Url(v);
        },
        data: v => v,
        sync: ['boolean', () => true]
    };
    if (Array.isArray(params)) {
        for (let r of params) {
            r = validator.Params(r, paramsStruct);
        }
    }
    else {
        params = validator.Params(params, paramsStruct);
    }
    return request.bind(this)('post-secure', params, { auth: true });
}
;
export async function mock(data, options) {
    await this.__connection;
    let { auth = false, method = 'POST', bypassAwaitConnection = false, responseType, contentType, progress } = options || {};
    options = Object.assign({ auth, method, bypassAwaitConnection, responseType, contentType }, {
        fetchOptions: { progress }
    });
    return request.bind(this)('mock', data, options);
}
;
//# sourceMappingURL=request.js.map